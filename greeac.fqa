{"name":"Gree AC","type":"com.fibaro.binarySwitch","apiVersion":"1.2","initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"0"},"title":"quickApp_device_761"},"sections":{"items":[{"components":[{"name":"labelAcStatus","style":{"weight":"1.2"},"text":"AC Is","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"labelAcMode","style":{"weight":"1.2"},"text":"AC mode is","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"labelAcTemperature","style":{"weight":"1.2"},"text":"Temperature","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"labelSwingStatus","style":{"weight":"1.2"},"text":"Swing Status","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"labelWdspd","style":{"weight":"1.2"},"text":"Fan Speed","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"components":[{"name":"buttonModeAuto","style":{"weight":"0.20"},"text":"ðŸ¤– Auto","type":"button","visible":true},{"name":"buttonModeCool","style":{"weight":"0.20"},"text":"â„ï¸ Cool","type":"button","visible":true},{"name":"buttonModeDry","style":{"weight":"0.20"},"text":"ðŸŒ€ Dry","type":"button","visible":true},{"name":"buttonModeFan","style":{"weight":"0.20"},"text":"âœ‡ Fan","type":"button","visible":true},{"name":"buttonModeHeat","style":{"weight":"0.20"},"text":"ðŸ”¥ Heat","type":"button","visible":true}],"style":{"weight":"1.2"},"type":"horizontal"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"components":[{"name":"buttonDecreasTemp","style":{"weight":"0.33"},"text":"Temp âž–","type":"button","visible":true},{"name":"buttonIncreaseTemp","style":{"weight":"0.33"},"text":"Temp âž•","type":"button","visible":true},{"name":"buttonFanSpeed","style":{"weight":"0.33"},"text":"Change âœ‡ Speed","type":"button","visible":true}],"style":{"weight":"1.2"},"type":"horizontal"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"components":[{"name":"buttonSwingDefault","style":{"weight":"0.33"},"text":"Default Swing","type":"button","visible":true},{"name":"buttonSwingFull","style":{"weight":"0.33"},"text":"Full Swing","type":"button","visible":true},{"name":"buttonSwingMiddle","style":{"weight":"0.33"},"text":"Keep static (middle)","type":"button","visible":true}],"style":{"weight":"1.2"},"type":"horizontal"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"components":[{"name":"buttonLight","style":{"weight":"0.33"},"text":"Light","type":"button","visible":true},{"name":"buttonQuiet","style":{"weight":"0.33"},"text":"Quiet","type":"button","visible":true},{"name":"energy","style":{"weight":"0.33"},"text":"Energy Saving","type":"button","visible":true}],"style":{"weight":"1.2"},"type":"horizontal"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"labelPair","style":{"weight":"1.2"},"text":"Pair status:","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"labelLightStatus","style":{"weight":"1.2"},"text":"Light Status","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"labelQuietStatus","style":{"weight":"1.2"},"text":"Quiet Status","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"labelEnergySavingStatus","style":{"weight":"1.2"},"text":"Energy Saving Status","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"components":[{"name":"turnOn","style":{"weight":"0.50"},"text":"ON","type":"button","visible":true},{"name":"turnOff","style":{"weight":"0.50"},"text":"OFF","type":"button","visible":true}],"style":{"weight":"1.2"},"type":"horizontal"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"pair","style":{"weight":"1.2"},"text":"Pair device","type":"button","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"buttonUpdateStatuses","style":{"weight":"1.2"},"text":"Update device to get Statuses","type":"button","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]}},"head":{"title":"quickApp_device_761"}}},"uiCallbacks":[{"callback":"modeAuto","eventType":"onReleased","name":"buttonModeAuto"},{"callback":"modeCool","eventType":"onReleased","name":"buttonModeCool"},{"callback":"modeDry","eventType":"onReleased","name":"buttonModeDry"},{"callback":"modeFan","eventType":"onReleased","name":"buttonModeFan"},{"callback":"modeHeat","eventType":"onReleased","name":"buttonModeHeat"},{"callback":"decreasTemp","eventType":"onReleased","name":"buttonDecreasTemp"},{"callback":"increasTemp","eventType":"onReleased","name":"buttonIncreaseTemp"},{"callback":"fanSpeed","eventType":"onReleased","name":"buttonFanSpeed"},{"callback":"setSwingDefault","eventType":"onReleased","name":"buttonSwingDefault"},{"callback":"setSwingFull","eventType":"onReleased","name":"buttonSwingFull"},{"callback":"setSwingMiddle","eventType":"onReleased","name":"buttonSwingMiddle"},{"callback":"setLight","eventType":"onReleased","name":"buttonLight"},{"callback":"setQuiet","eventType":"onReleased","name":"buttonQuiet"},{"callback":"energy","eventType":"onReleased","name":"energy"},{"callback":"turnOn","eventType":"onReleased","name":"turnOn"},{"callback":"turnOff","eventType":"onReleased","name":"turnOff"},{"callback":"pair","eventType":"onReleased","name":"pair"},{"callback":"readAllStatuses","eventType":"onReleased","name":"buttonUpdateStatuses"}],"quickAppVariables":[{"name":"ac_ip","type":"string","value":"static_ac_unit_ip"},{"name":"ac_key","type":"string","value":"false"},{"name":"ac_mac","type":"string","value":"false"},{"name":"ac_cid","type":"string","value":"false"},{"name":"ac_name","type":"string","value":"false"},{"name":"ac_brand","type":"string","value":"gree"}],"typeTemplateInitialized":true},"files":[{"name":"main","isMain":true,"isOpen":true,"content":"--\n-- System variables\n--\n__TAG = \"GREE AC\" .. plugin.mainDeviceId\nQuickApp.version = 1.00\nQuickApp._VERSION = \"1.00\"\nQuickApp.translations = {\n    labels = {\n        temperature     = \"Temperature: \",\n        pair_ok     = \"Device connected âœ…\",\n        pair_failed = \"Device not connected âŒ\",\n        ac_on       = \"âœ… AC Is ON\",\n        ac_off      = \"âŒ AC Is OFF\",\n        mode_auto   = \"AC mode: AUTO ðŸ¤–\",\n        mode_cool   = \"AC mode: COOL â„ï¸\",\n        mode_dry    = \"AC mode: DRY ðŸŒ€\",\n        mode_fan    = \"AC mode: FAN âœ‡\",\n        mode_heat  = \"AC mode: HEAT ðŸ”¥\",\n        windspeed_auto = \"Fan Set: AUTO\",\n        windspeed_low = \"Fan Set: LOW\",\n        windspeed_medium_low = \"Fan Set: MEDIUM LOW\",\n        windspeed_medium_hight = \"Fan Set: MEDIUM HIGH\",\n        windspeed_hight = \"Fan Set: HIGH\",\n        windspeed_undefined     = \"Fan Set: Undefined\",\n        lights_on  = \"Lights on âœ…\",\n        lights_off = \"Lights off âŒ\",\n        quiet_on   = \"Quiet mode On âœ…\",\n        quiet_off  = \"Quiet mode Off âŒ\",\n        energy_on = \"Save Energy On âœ…\",\n        energy_off = \"Save Energy Off âŒ\",\n        swing_default = \"Swing mode: Default\",\n        swing_full = \"Swing mode: Full Swing\",\n        swing_middle = \"Swing mode: Fixed in the middle position (2/5)\",\n        swing_undefined = \"Swing mode: Undefined\",\n    },\n}\n\nlocal udp = net.UDPSocket({ broadcast = true, timeout = 2000 })\n\nfunction QuickApp:onInit()\n    -- Load Translations\n    self.trans = self.translations\n\n    -- Whole Variables\n    self.ac_ip = self:getVariable(\"ac_ip\")\n    self.ac_name = self:getVariable(\"ac_name\")\n    self.ac_cid = self:getVariable(\"ac_cid\")\n    self.ac_mac = self:getVariable(\"ac_mac\")\n    self.ac_key = self:getVariable(\"ac_key\")\n    self.ac_brand = self:getVariable(\"ac_brand\")\n    self.openssl_key = 'a3K8Bx%2r8Y7#xDh' -- Do not change this param\n\n    -- Default AC Unit Modes\n    self.ac_status = 0; -- AC IS ON OFF ( 0 / 1)\n    self.ac_mode = 0; -- Default AC Unit Mod (Auto, Cool, Dry, Fan, Heat)\n    self.ac_fan_speed = 0 -- -- 0:auto, 1: low, 2: medium-low (not available on 3-speed units), 3: medium, 4: medium-high (not available on 3-speed units), 5: high\n    self.ac_default_light = 1 -- Default is Light On\n    self.ac_default_quiet = 0 -- Default is Quiet On\n    self.ac_default_energy = 0-- Default is Energy Saving On\n    self.quickpp_min_operating_temperature = 16 -- Min Operating Temp\n    self.quickapp_max_operating_temperature = 30 -- Max Operating Temp\n    self.ac_default_temp = 24 -- Default Operating Temp\n    self.ac_default_swing = 1 -- 0: default 1: swing in full range, 2: fixed in the upmost position (1/5), 3: fixed in the middle-up position (2/5), 4: fixed in the middle position (3/5), 5: fixed in the middle-low position (4/5), 6: fixed in the lowest position (5/5), 7: swing in the downmost region (5/5), 8: swing in the middle-low region (4/5), 9: swing in the middle region (3/5), 10: swing in the middle-up region (2/5), 11: swing in the upmost region (1/5)\n\n    -- === ON INIT GET DEVICE STATUSES\n    -- If device configure, ead statuses\n    if (self:getVariable(\"ac_key\") ~= false or self:getVariable(\"ac_key\") ~= 'false' or self:getVariable(\"ac_key\") ~= '') then\n        self.pool_interval = 300000 -- 5min\n        self:requestLoop()\n    end\nend\n\n-- Make loop\nfunction QuickApp:requestLoop()\n    -- Get power status is it ON or OFF\n    self:getPowerStatus()\n    self:getModeStatus()\n    self:getsetTemp()\n    self:getModeFanSpeed()\n    self:getSwingStatus()\n    self:getLights()\n    self:getQuiet()\n    self:getEnergySaving()\n\n    self:debug(\"Reading AC Status\")\n\n    fibaro.setTimeout(self.pool_interval, function() self:requestLoop() end) -- looping part\nend\n\n-- ========== AC Unit Commands\n-- ===== Actions to AC Unit\n-- Basic On / Off\nfunction QuickApp:turnOn()\n    local sPack = '{\"opt\": [\"Pow\"], \"p\": [1],  \"t\": \"cmd\"}'\n    local pack = self:formatPackTo(sPack)\n\n    self:transmitUdp(pack, 'pow', 1)\nend\n\nfunction QuickApp:turnOff()\n    local sPack = '{\"opt\": [\"Pow\"], \"p\": [0],  \"t\": \"cmd\"}'\n    local pack = self:formatPackTo(sPack)\n\n    self:transmitUdp(pack, 'pow', 0)\nend\n\n-- Modes (Auto, Cool, Dry, Fan, Heat)\nfunction QuickApp:modeAuto()\n    local sPack = '{\"opt\": [\"Mod\"], \"p\": [0],  \"t\": \"cmd\"}'\n    local pack = self:formatPackTo(sPack)\n\n    self:transmitUdp(pack, 'mod', 0)\nend\n\nfunction QuickApp:modeCool()\n    local sPack = '{\"opt\": [\"Mod\"], \"p\": [1],  \"t\": \"cmd\"}'\n    local pack = self:formatPackTo(sPack)\n\n    self:transmitUdp(pack, 'mod', 1)\nend\n\nfunction QuickApp:modeDry()\n    local sPack = '{\"opt\": [\"Mod\"], \"p\": [2],  \"t\": \"cmd\"}'\n    local pack = self:formatPackTo(sPack)\n\n    self:transmitUdp(pack, 'mod', 2)\nend\n\nfunction QuickApp:modeFan()\n    local sPack = '{\"opt\": [\"Mod\"], \"p\": [3],  \"t\": \"cmd\"}'\n    local pack = self:formatPackTo(sPack)\n\n    self:transmitUdp(pack, 'mod', 3)\nend\n\nfunction QuickApp:modeHeat()\n    local sPack = '{\"opt\": [\"Mod\"], \"p\": [4],  \"t\": \"cmd\"}'\n    local pack = self:formatPackTo(sPack)\n\n    self:transmitUdp(pack, 'mod', 4)\nend\n\n-- Increase / Decrease Temp\nfunction QuickApp:decreasTemp()\n    if (self.ac_default_temp > self.quickpp_min_operating_temperature and self.ac_default_temp <= self.quickapp_max_operating_temperature) then\n        self.ac_default_temp = self.ac_default_temp - 1\n    elseif (self.ac_default_temp > self.quickpp_min_operating_temperature) then\n        self.ac_default_temp = self.ac_default_temp - 1\n    else\n        self.ac_default_temp = self.ac_default_temp + 1\n    end\n\n    -- Submit Data To Ac Unit\n    local sPack = '{\"opt\": [\"TemUn\", \"SetTem\"], \"p\": [0, '.. self.ac_default_temp ..'],  \"t\": \"cmd\"}'\n    local pack = self:formatPackTo(sPack)\n\n    self:transmitUdp(pack, 'settemp', self.ac_default_temp)\nend\n\nfunction QuickApp:increasTemp()\n    if (self.ac_default_temp > self.quickpp_min_operating_temperature and self.ac_default_temp < self.quickapp_max_operating_temperature) then\n        self.ac_default_temp = self.ac_default_temp + 1\n    elseif (self.ac_default_temp >= self.quickapp_max_operating_temperature) then\n        self.ac_default_temp = self.ac_default_temp - 1\n    else\n        self.ac_default_temp = self.ac_default_temp + 1\n    end\n\n    -- Submit Data To Ac Unit\n    local sPack = '{\"opt\": [\"TemUn\", \"SetTem\"], \"p\": [0, '.. self.ac_default_temp ..'],  \"t\": \"cmd\"}'\n    local pack = self:formatPackTo(sPack)\n\n    self:transmitUdp(pack, 'settemp', self.ac_default_temp)\nend\n\n-- Fan speed (From 0 to 5)\nfunction QuickApp:fanSpeed()\n    if (self.ac_fan_speed >= 0 and self.ac_fan_speed < 5) then\n        self.ac_fan_speed = self.ac_fan_speed + 1\n    elseif (self.ac_fan_speed == 0 and self.ac_fan_speed ~= 5) then\n        self.ac_fan_speed = self.ac_fan_speed + 1\n    elseif (self.ac_fan_speed == 5) then\n        self.ac_fan_speed = 0\n    else\n        self.ac_fan_speed = self.ac_fan_speed - 1\n    end\n\n    -- Submit Data To Ac Unit\n    local sPack = '{\"opt\": [\"WdSpd\"], \"p\": ['.. self.ac_fan_speed ..'],  \"t\": \"cmd\"}'\n    local pack = self:formatPackTo(sPack)\n\n    self:transmitUdp(pack, 'wdspd', self.ac_fan_speed)\nend\n\n-- Svings modes\nfunction QuickApp:setSwingDefault()\n    -- Submit Data To Ac Unit\n    local sPack = '{\"opt\": [\"SwUpDn\"], \"p\": [0],  \"t\": \"cmd\"}'\n    local pack = self:formatPackTo(sPack)\n\n    self:transmitUdp(pack, 'swupdn', 0)\nend\n\nfunction QuickApp:setSwingFull()\n    -- Submit Data To Ac Unit\n    local sPack = '{\"opt\": [\"SwUpDn\"], \"p\": [1],  \"t\": \"cmd\"}'\n    local pack = self:formatPackTo(sPack)\n\n    self:transmitUdp(pack, 'swupdn', 1)\nend\n\nfunction QuickApp:setSwingMiddle()\n    -- Submit Data To Ac Unit\n    local sPack = '{\"opt\": [\"SwUpDn\"], \"p\": [3],  \"t\": \"cmd\"}'\n    local pack = self:formatPackTo(sPack)\n\n    self:transmitUdp(pack, 'swupdn', 3)\nend\n\n-- Additionals\nfunction QuickApp:setLight()\n    if (self.ac_default_light == 1) then\n        self.ac_default_light = 0\n    else\n        self.ac_default_light = 1\n    end\n\n    -- Submit Data To Ac Unit\n    local sPack = '{\"opt\": [\"Lig\"], \"p\": ['.. self.ac_default_light ..'],  \"t\": \"cmd\"}'\n    local pack = self:formatPackTo(sPack)\n\n    self:transmitUdp(pack, 'lig', self.ac_default_light)\nend\n\nfunction QuickApp:setQuiet()\n    if (self.ac_default_quiet == 1) then\n        self.ac_default_quiet = 0\n    else\n        self.ac_default_quiet = 1\n    end\n\n    -- Submit Data To Ac Unit\n    local sPack = '{\"opt\": [\"Quiet\"], \"p\": ['.. self.ac_default_quiet ..'],  \"t\": \"cmd\"}'\n    local pack = self:formatPackTo(sPack)\n\n    self:transmitUdp(pack, 'quiet', self.ac_default_quiet)\nend\n\nfunction QuickApp:energy()\n    if (self.ac_default_energy == 1) then\n        self.ac_default_energy = 0\n    else\n        self.ac_default_energy = 1\n    end\n\n    -- Submit Data To Ac Unit\n    local sPack = '{\"opt\": [\"SvSt\"], \"p\": ['.. self.ac_default_energy ..'],  \"t\": \"cmd\"}'\n    local pack = self:formatPackTo(sPack)\n\n    self:transmitUdp(pack, 'svst', self.ac_default_energy)\nend\n\n-- ===== Actions FROM AC Unit\n-- Manual trigger\nfunction QuickApp:readAllStatuses()\n    if (self.ac_key == 'false') then\n        self:updateView(\"labelPair\", \"text\", self.trans.labels.pair_fail)\n        self:trace('Was trying to not configure Gree AC Unit statuses.')\n    else\n        self:updateView(\"labelPair\", \"text\", self.trans.labels.pair_ok)\n\n        self:getPowerStatus()\n        self:getModeStatus()\n        self:getsetTemp()\n        self:getModeFanSpeed()\n        self:getSwingStatus()\n        self:getLights()\n        self:getQuiet()\n        self:getEnergySaving()   \n    end \nend\n-- end.\n\nfunction QuickApp:getPowerStatus()\n    local sPack = '{\"cols\": [\"Pow\"], \"mac\": \"'.. self.ac_mac ..'\", \"t\": \"status\"}'\n    local pack = self:formatPackFrom(sPack)\n\n    self:transmitUdp(pack, 'getPow', 'getStatus')\nend\n\nfunction QuickApp:getModeStatus()\n    local sPack = '{\"cols\": [\"Mod\"], \"mac\": \"'.. self.ac_mac ..'\", \"t\": \"status\"}'\n    local pack = self:formatPackFrom(sPack)\n\n    self:transmitUdp(pack, 'getMod', 'getStatus')\nend\n\nfunction QuickApp:getsetTemp()\n    local sPack = '{\"cols\": [\"SetTem\"], \"mac\": \"'.. self.ac_mac ..'\", \"t\": \"status\"}'\n    local pack = self:formatPackFrom(sPack)\n\n    self:transmitUdp(pack, 'getTem', 'getStatus')\nend\n\nfunction QuickApp:getModeFanSpeed()\n    local sPack = '{\"cols\": [\"WdSpd\"], \"mac\": \"'.. self.ac_mac ..'\", \"t\": \"status\"}'\n    local pack = self:formatPackFrom(sPack)\n\n    self:transmitUdp(pack, 'getwdspd', 'getStatus')\nend\n\nfunction QuickApp:getSwingStatus()\n    local sPack = '{\"cols\": [\"SwUpDn\"], \"mac\": \"'.. self.ac_mac ..'\", \"t\": \"status\"}'\n    local pack = self:formatPackFrom(sPack)\n\n    self:transmitUdp(pack, 'getswupdn', 'getStatus')\nend\n\nfunction QuickApp:getLights()\n    local sPack = '{\"cols\": [\"Lig\"], \"mac\": \"'.. self.ac_mac ..'\", \"t\": \"status\"}'\n    local pack = self:formatPackFrom(sPack)\n\n    self:transmitUdp(pack, 'getLig', 'getStatus')\nend\n\nfunction QuickApp:getQuiet()\n    local sPack = '{\"cols\": [\"Quiet\"], \"mac\": \"'.. self.ac_mac ..'\", \"t\": \"status\"}'\n    local pack = self:formatPackFrom(sPack)\n\n    self:transmitUdp(pack, 'getQuiet', 'getStatus')\nend\n\nfunction QuickApp:getEnergySaving()\n    local sPack = '{\"cols\": [\"SvSt\"], \"mac\": \"'.. self.ac_mac ..'\", \"t\": \"status\"}'\n    local pack = self:formatPackFrom(sPack)\n\n    self:transmitUdp(pack, 'getSvSt', 'getStatus')\nend\n\n\n-- ===== ADDITIONAL HELPERS\n-- Function Encrypt Data\nfunction QuickApp:fnEncrypt(data, openssl_key)\n    -- PKCS#7 padding\n    local paddedData1 = padding.padPKCS7(data)\n    -- local unpaddedData1 = padding.unpadPKCS7(paddedData1)\n\n    -- some encryption example ECB 128\n    local keystring1 = padding.padPKCS7(openssl_key,16,true)\n    local key1 = {string.byte(keystring1,1,#keystring1)}\n\n    -- result\n    local response = aeslib.encryptString(key1, paddedData1, ciphermode.encryptECB)\n    local response = base64.to_base64(response)\n\n    return response\nend\n\n-- Function Format pack\nfunction QuickApp:formatPackTo(pack)\n    local sendPack = self:fnEncrypt(pack, self.ac_key)\n    local pack = '{\"t\": \"pack\", \"i\": 0, \"uid\": 0, \"cid\": \"'.. self.ac_cid ..'\", \"tcid\": \"\", \"pack\": \"'.. sendPack ..'\"}'\n\n    return pack\nend\n\nfunction QuickApp:formatPackFrom(pack)\n    local sendPack = self:fnEncrypt(pack, self.ac_key)\n    local pack = '{\"cid\": \"app\", \"i\": 0, \"pack\": \"'.. sendPack ..'\", \"t\": \"pack\", \"tcid\": \"'.. self.ac_mac ..'\", \"uid\": 0 }'\n  \n    return pack\nend\n\n-- Update dashboard\nfunction QuickApp:updateAcUnitViewDashboard(command, value)\n    -- Power\n    if (command == 'pow') then\n        if (value == 0) then\n            self:updateView(\"labelAcStatus\", \"text\", self.trans.labels.ac_off)\n        elseif (value == 1) then\n            self:updateView(\"labelAcStatus\", \"text\", self.trans.labels.ac_on)\n        end\n\n        -- Power variable\n        self.ac_status = value;\n    end\n\n    -- Mode\n    if (command == 'mod') then\n        if (value == 0) then\n            self:updateView(\"labelAcMode\", \"text\", self.trans.labels.mode_auto)\n        elseif (value == 1) then\n            self:updateView(\"labelAcMode\", \"text\", self.trans.labels.mode_cool)\n        elseif (value == 2) then\n            self:updateView(\"labelAcMode\", \"text\", self.trans.labels.mode_dry)\n        elseif (value == 3) then\n            self:updateView(\"labelAcMode\", \"text\", self.trans.labels.mode_fan)\n        elseif (value == 4) then\n            self:updateView(\"labelAcMode\", \"text\", self.trans.labels.mode_heat)\n        end\n\n        -- Update mode\n        self.ac_mode = value;\n    end\n\n    -- Set Temp\n    if (command == 'settemp') then\n        self:updateView(\"labelAcTemperature\", \"text\", self.trans.labels.temperature ..\" \".. value ..\" C\")\n    end\n\n    -- Wind Speed\n    if (command == 'wdspd') then\n        if (value == 0) then\n            self:updateView(\"labelWdspd\", \"text\", self.trans.labels.windspeed_auto)\n        elseif (value == 1) then\n            self:updateView(\"labelWdspd\", \"text\", self.trans.labels.windspeed_low)\n        elseif (value == 2) then\n            self:updateView(\"labelWdspd\", \"text\", self.trans.labels.windspeed_medium_low)\n        elseif (value == 3) then\n            self:updateView(\"labelWdspd\", \"text\", self.trans.labels.windspeed_medium_hight)\n        elseif (value == 4) then\n            self:updateView(\"labelWdspd\", \"text\", self.trans.labels.windspeed_hight)\n        else\n            -- Fan speed which not defined in strings, I can do it, but not needed for v1\n            self:updateView(\"labelWdspd\", \"text\", self.trans.labels.windspeed_undefined)\n        end\n\n        -- Update Fan Speed\n        self.ac_fan_speed = value;\n    end\n\n    -- Swing\n    if (command == 'swupdn') then\n        if (value == 0) then\n            self:updateView(\"labelSwingStatus\", \"text\", self.trans.labels.swing_default)\n        elseif (value == 1) then\n            self:updateView(\"labelSwingStatus\", \"text\", self.trans.labels.swing_full)\n        elseif (value == 3) then\n            self:updateView(\"labelSwingStatus\", \"text\", self.trans.labels.swing_middle)\n        else\n            self:updateView(\"labelSwingStatus\", \"text\", self.trans.labels.swing_undefined)\n        end\n\n        self.ac_default_swing = value;\n    end\n\n    -- Light\n    if (command == 'lig') then\n        if (value == 0) then\n            self:updateView(\"labelLightStatus\", \"text\", self.trans.labels.lights_off)\n        elseif (value == 1) then\n            self:updateView(\"labelLightStatus\", \"text\", self.trans.labels.lights_on)\n        end\n    end\n\n    -- Quiet\n    if (command == 'quiet') then\n        if (value == 0) then\n            self:updateView(\"labelQuietStatus\", \"text\", self.trans.labels.quiet_off)\n        elseif (value == 1) then\n            self:updateView(\"labelQuietStatus\", \"text\", self.trans.labels.quiet_on)\n        end\n    end\n\n    -- Energy\n    if (command == 'svst') then\n        if (value == 0) then\n            self:updateView(\"labelEnergySavingStatus\", \"text\", self.trans.labels.energy_off)\n        elseif (value == 1) then\n            self:updateView(\"labelEnergySavingStatus\", \"text\", self.trans.labels.energy_on)\n        end\n    end\n\n    --=== Read Status ===--\n    if (command == 'status_pow') then\n        if (value == 0) then\n            self:updateView(\"labelAcStatus\", \"text\", self.trans.labels.ac_off)\n        elseif (value == 1) then\n            self:updateView(\"labelAcStatus\", \"text\", self.trans.labels.ac_on)\n        end\n\n        -- Power variable\n        self.ac_status = value;\n    end\n\n    if (command == 'status_mod') then\n        if (value == 0) then\n            self:updateView(\"labelAcMode\", \"text\", self.trans.labels.mode_auto)\n        elseif (value == 1) then\n            self:updateView(\"labelAcMode\", \"text\", self.trans.labels.mode_cool)\n        elseif (value == 2) then\n            self:updateView(\"labelAcMode\", \"text\", self.trans.labels.mode_dry)\n        elseif (value == 3) then\n            self:updateView(\"labelAcMode\", \"text\", self.trans.labels.mode_fan)\n        elseif (value == 4) then\n            self:updateView(\"labelAcMode\", \"text\", self.trans.labels.mode_heat)\n        end\n\n        -- Update mode\n        self.ac_mode = value;\n    end\n\n    if (command == 'status_settem') then\n        self:updateView(\"labelAcTemperature\", \"text\", self.trans.labels.temperature ..\" \".. value ..\" C\")\n\n        self.ac_default_temp = value\n    end\n\n    if (command == 'status_wdspd') then\n        if (value == 0) then\n            self:updateView(\"labelWdspd\", \"text\", self.trans.labels.windspeed_auto)\n        elseif (value == 1) then\n            self:updateView(\"labelWdspd\", \"text\", self.trans.labels.windspeed_low)\n        elseif (value == 2) then\n            self:updateView(\"labelWdspd\", \"text\", self.trans.labels.windspeed_medium_low)\n        elseif (value == 3) then\n            self:updateView(\"labelWdspd\", \"text\", self.trans.labels.windspeed_medium_hight)\n        elseif (value == 4) then\n            self:updateView(\"labelWdspd\", \"text\", self.trans.labels.windspeed_hight)\n        else\n            -- Fan speed which not defined in strings, I can do it, but not needed for v1\n            self:updateView(\"labelWdspd\", \"text\", self.trans.labels.windspeed_undefined)\n        end\n\n        -- Update Fan Speed\n        self.ac_fan_speed = value;\n    end\n\n    -- Swing\n    if (command == 'status_swupdn') then\n        if (value == 0) then\n            self:updateView(\"labelSwingStatus\", \"text\", self.trans.labels.swing_default)\n        elseif (value == 1) then\n            self:updateView(\"labelSwingStatus\", \"text\", self.trans.labels.swing_full)\n        elseif (value == 3) then\n            self:updateView(\"labelSwingStatus\", \"text\", self.trans.labels.swing_middle)\n        else\n            self:updateView(\"labelSwingStatus\", \"text\", self.trans.labels.swing_undefined)\n        end\n\n        self.ac_default_swing = value;\n    end\n\n    -- Light\n    if (command == 'status_lig') then\n        if (value == 0) then\n            self:updateView(\"labelLightStatus\", \"text\", self.trans.labels.lights_off)\n        elseif (value == 1) then\n            self:updateView(\"labelLightStatus\", \"text\", self.trans.labels.lights_on)\n        end\n    end\n\n    -- Quiet\n    if (command == 'status_quiet') then\n        if (value == 0) then\n            self:updateView(\"labelQuietStatus\", \"text\", self.trans.labels.quiet_off)\n        elseif (value == 1) then\n            self:updateView(\"labelQuietStatus\", \"text\", self.trans.labels.quiet_on)\n        end\n    end\n\n    -- Energy\n    if (command == 'status_svst') then\n        if (value == 0) then\n            self:updateView(\"labelEnergySavingStatus\", \"text\", self.trans.labels.energy_off)\n        elseif (value == 1) then\n            self:updateView(\"labelEnergySavingStatus\", \"text\", self.trans.labels.energy_on)\n        end\n    end\nend\n\n-- Function Transmit UDP Pack\nfunction QuickApp:transmitUdp(msg, command, value)\n    udp:sendTo(msg, self.ac_ip, 7000, {\n        success = function()\n            response = self:receiveUdp(command, value)\n        end,\n        error = function(error)\n            -- self:debug('Error: To read QuickApp:transmitUdp UDP message.')\n        end    \n    })\nend\n\n-- Function Read UDP network\nfunction QuickApp:receiveUdp(command, value)\n    udp:receive({\n        success = function(data)\n            -- Raw response pack from AC Unit\n            package = base64.from_base64(json.decode(data).pack)\n\n            -- Decrypt received data pack\n            local keystring1 = padding.padPKCS7(self.ac_key,16,true)\n            local key1 = {string.byte(keystring1,1,#keystring1)}\n            local response = padding.unpadPKCS7(aeslib.decryptString(key1, package, ciphermode.decryptECB))\n\n            -- Update view data\n            if (value == 'getStatus') then\n                response = json.decode(response)\n                which_param = response.cols[1]\n                what_status = tonumber(response.dat[1])\n\n                -- which_param\n                -- self:updateView(\"labelAcStatus\", \"text\", string.lower(\"status_\".. which_param))\n\n\n-- self.trans.labels.temperature ..\" \".. value ..\" C\"\n\n                if (response.r == 200) then\n                    self:updateAcUnitViewDashboard(string.lower(\"status_\".. which_param), what_status)\n                else\n                    self:updateAcUnitViewDashboard(string.lower(\"status_\".. which_param), 0)\n                end\n            else\n                response_code = json.decode(response).r\n\n                if (response_code == 200) then\n                    self:updateAcUnitViewDashboard(command, value)\n                else\n                    -- self:debug('Error: Function: QuickApp:receiveUdp. Package dont understand, because the response code is not 200')\n                end\n            end\n        end,\n        error = function(error)\n            -- self:debug('Error: To read QuickApp:receiveUdp UDP message.')\n        end\n    })\nend\n\n-- GREE AC UNIT PAIRING WITH FIBARO. PAIR Setup\nfunction QuickApp:pair()\n    -- 1 Step. Scan to get Data of AC Unit\n    local msg = '{\\\"t\\\":\\\"scan\\\"}'\n\n    -- === Step 1 === Scan network to Find AC Unit\n    udp:sendTo(msg, self.ac_ip, 7000, {\n        success = function()\n            -- self:trace(\"Scan Message to UDP was send successfully\")\n            local response = self:pairReadUdp(1) -- listen response from device\n            -- self:trace('Step 1, done')\n\n            -- === Step 2, if success step 1 === \n            local sPack = '{\"mac\": \"'.. self.ac_mac ..'\", \"t\": \"bind\",\"uid\": 0}'\n            local sEncPack = self:fnEncrypt(sPack, self.openssl_key)\n            local msg = '{\"cid\": \"'.. self.ac_cid ..'\", \"i\": 1, \"pack\": \"'.. sEncPack ..'\", \"t\": \"pack\", \"tcid\": \"app\", \"uid\": 0}'\n\n            udp:sendTo(msg, self.ac_ip, 7000, {\n                success = function()\n                    local response = self:pairReadUdp(2)\n                    -- self:trace('Step 2, done')\n                end,\n                error = function(error)\n                    self:debug('Pairing Step 2 failed.')\n                end    \n            })\n            -- ===\n        end,\n        error = function(error)\n            self:debug('Pairing Step 1 failed.')\n        end    \n    })\nend\n\nfunction QuickApp:pairReadUdp(step)\n    udp:receive({\n        success = function(data)\n            -- Received data pack\n            data = base64.from_base64(json.decode(data).pack)\n\n            -- Decrypt received data pack\n            local keystring1 = padding.padPKCS7(self.openssl_key,16,true)\n            local key1 = {string.byte(keystring1,1,#keystring1)}\n            -- local response = aeslib.decryptString(key1, pack, ciphermode.decryptECB)\n\n            local response = padding.unpadPKCS7(aeslib.decryptString(key1, data, ciphermode.decryptECB))\n\n            if (step == 1) then\n                local cid = json.decode(response).cid\n                local mac = json.decode(response).mac\n                local name = json.decode(response).name\n                local brand = json.decode(response).brand\n        \n                -- Write data to variables for later usage\n                self:setVariable(\"ac_cid\", cid)\n                self:setVariable(\"ac_mac\", mac)\n                self:setVariable(\"ac_name\", name)\n                self:setVariable(\"ac_brand\", brand)\n            end\n\n            if (step == 2) then\n                local key = json.decode(response).key\n\n                -- Write data to variables for later usage\n                self:setVariable(\"ac_key\", key)\n\n                -- Update connected label\n                self:updateView(\"labelPair\", \"text\", self.trans.labels.pair_ok)\n\n            end\n        end,\n        error = function(error)\n            self:debug('Pairing error')\n        end\n    })\nend \n"},{"name":"aeslib","isMain":false,"isOpen":false,"content":"---------------------------------------- pure LUA AES Lib for HC3 QuickApps ----------------------------------------- \naeslib = {\n  _VERSION     = \"0.2\",\n  _DESCRIPTION = \"pura LUA AES LIB\",\n  _URL         = \"http://quickapps.info\",\n  _LICENSE     = [[\n      (c) tinman/Intuitech\n  ]]\n}\n\n--------------------------------------------------------------------------------\n-- USAGE:\n-- call aeslib.decryptString or aeslib.encryptString\n-- there is additional padding and aestil lib inside, check QA example\n--------------------------------------------------------------------------------\n-- Decrypt strings\n-- key - byte array with key\n-- string - string to decrypt\n-- modefunction - ciphermode.decryptECB,ciphermode.decryptCBC,ciphermode.decryptOFB,ciphermode.decryptCFB,ciphermode.decryptCTR\n-- iv - optional iv for modefunction\nfunction aeslib.decryptString(key, data, modeFunction, iv)\n    return ciphermode.decryptString(key, data, modeFunction, iv)\nend\n\n-- Encrypt strings\n-- key - byte array with key\n-- string - string to encrypt\n-- modefunction - ciphermode.encryptECB,ciphermode.encryptCBC,ciphermode.encryptOFB,ciphermode.encryptCFB,ciphermode.encryptCTR)\n-- iv - optional iv for modefunction\nfunction aeslib.encryptString(key, data, modeFunction, iv)\n    return ciphermode.encryptString(key, data, modeFunction, iv)\nend\n\n--------------------------------------------------------------------------------\n-- small extra -> padding lib : PKCS#7, ANSI X9.23, ISO7816-4, ZERO and SPACE \n--------------------------------------------------------------------------------\n\npadding = {\n  _VERSION     = \"lua-resty-nettle.padding.lua v1.5 - 2020-04-01\",\n  _LICENSE     = [[\n  Copyright (c) 2014 - 2020, Aapo Talvensaari\n  All rights reserved.\n  \n  Redistribution and use in source and binary forms, with or without modification,\n  are permitted provided that the following conditions are met:\n  \n  * Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n  \n  * Redistributions in binary form must reproduce the above copyright notice, this\n  list of conditions and the following disclaimer in the documentation and/or\n  other materials provided with the distribution.\n  \n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. \n  ]]\n}\n\nfunction padding.padPKCS7(data, blocksize, optional)\n  blocksize = blocksize or 16\n  if type(blocksize) ~= \"number\" then\n    return nil, \"invalid block size data type\"\n  end\n  if blocksize < 1 or blocksize > 256 then\n    return nil, \"invalid block size\"\n  end\n  local ps = blocksize - #data % blocksize\n  if optional and ps == blocksize then return data end\n  return data .. string.rep(string.char(ps), ps)\nend\n\nfunction padding.unpadPKCS7(data, blocksize)\n  blocksize = blocksize or 16\n  if type(blocksize) ~= \"number\" then\n    return nil, \"invalid block size data type\"\n  end\n  if blocksize < 1 or blocksize > 256 then\n    return nil, \"invalid block size\"\n  end\n  local len = #data\n  if len % blocksize ~= 0 then\n    return nil, \"data length is not a multiple of the block size\"\n  end\n  local chr = string.sub(data, -1)\n  local rem = string.byte(chr)\n  if rem > 0 and rem <= blocksize then\n    local chk = string.sub(data, -rem)\n    if chk == string.rep(chr, rem) then\n      return string.sub(data, 1, len - rem)\n    end\n  end\n  return data\nend\n\nfunction padding.padANSIX923(data, blocksize, optional)\n  blocksize = blocksize or 16\n  if type(blocksize) ~= \"number\" then\n    return nil, \"invalid block size data type\"\n  end\n  if blocksize < 1 or blocksize > 256 then\n    return nil, \"invalid block size\"\n  end\n  local ps = blocksize - #data % blocksize\n  if optional and ps == blocksize then return data end\n  return data .. string.rep(\"\\0\", ps - 1) .. string.char(ps)\nend\n\nfunction padding.unpadANSIX923(data, blocksize)\n  blocksize = blocksize or 16\n  if type(blocksize) ~= \"number\" then\n    return nil, \"invalid block size data type\"\n  end\n  if blocksize < 1 or blocksize > 256 then\n    return nil, \"invalid block size\"\n  end\n  local len = #data\n  if len % blocksize ~= 0 then\n    return nil, \"data length is not a multiple of the block size\"\n  end\n  local chr = string.sub(data, -1)\n  local rem = string.byte(chr)\n  if rem > 0 and rem <= blocksize then\n    local chk = string.sub(data, -rem)\n    if chk == string.rep(\"\\0\", rem - 1) .. chr then\n      return string.sub(data, 1, len - rem)\n    end\n  end\n  return data\nend\n\nfunction padding.padZERO(data, blocksize, optional)\n  blocksize = blocksize or 16\n  if type(blocksize) ~= \"number\" then\n    return nil, \"invalid block size data type\"\n  end\n  if blocksize < 1 or blocksize > 256 then\n    return nil, \"invalid block size\"\n  end\n  local ps = blocksize - #data % blocksize\n  if optional and ps == blocksize then return data end\n  return data .. string.rep(\"\\0\", ps)\nend\n\nfunction padding.unpadZERO(data, blocksize)\n  blocksize = blocksize or 16\n  if type(blocksize) ~= \"number\" then\n    return nil, \"invalid block size data type\"\n  end\n  if blocksize < 1 or blocksize > 256 then\n    return nil, \"invalid block size\"\n  end\n  local len = #data\n  if len % blocksize ~= 0 then\n    return nil, \"data length is not a multiple of the block size\"\n  end\n  data = string.gsub(data, \"%z+$\", \"\")\n  local rem = len - #data\n  if rem < 0 or rem > blocksize then\n    return nil, \"data has invalid padding\"\n  end\n  return data\nend\n\nfunction padding.padISO7816_4(data, blocksize, optional)\n  blocksize = blocksize or 16\n  if type(blocksize) ~= \"number\" then\n    return nil, \"invalid block size data type\"\n  end\n  if blocksize < 1 or blocksize > 256 then\n    return nil, \"invalid block size\"\n  end\n  local ps = blocksize - #data % blocksize\n  if optional and ps == blocksize then return data end\n  return data .. \"\\x80\" .. string.rep(\"\\0\", ps - 1)\nend\n\nfunction padding.unpadISO7816_4(data, blocksize)\n  blocksize = blocksize or 16\n  if type(blocksize) ~= \"number\" then\n    return nil, \"invalid block size data type\"\n  end\n  if blocksize < 1 or blocksize > 256 then\n    return nil, \"invalid block size\"\n  end\n  local len = #data\n  if len % blocksize ~= 0 then\n    return nil, \"data length is not a multiple of the block size\"\n  end\n  local d = string.gsub(data, \"%z+$\", \"\")\n  if string.sub(d, -1) == \"\\x80\" then\n    return string.sub(d, 1, #d - 1)\n  end\n  return data\nend\n\nfunction padding.padSPACE(data, blocksize, optional)\n  blocksize = blocksize or 16\n  if type(blocksize) ~= \"number\" then\n    return nil, \"invalid block size data type\"\n  end\n  if blocksize < 1 or blocksize > 256 then\n    return nil, \"invalid block size\"\n  end\n  local ps = blocksize - #data % blocksize\n  if optional and ps == blocksize then return data end\n  return data .. string.rep(\" \", ps)\nend\n\nfunction padding.unpadSPACE(data, blocksize)\n  blocksize = blocksize or 16\n  if type(blocksize) ~= \"number\" then\n    return nil, \"invalid block size data type\"\n  end\n  if blocksize < 1 or blocksize > 256 then\n    return nil, \"invalid block size\"\n  end\n  local len = #data\n  if len % blocksize ~= 0 then\n    return nil, \"data length is not a multiple of the block size\"\n  end\n  data = string.gsub(data, \" +$\", \"\")\n  local rem = len - #data\n  if rem < 0 or rem > blocksize then\n    return nil, \"data has invalid padding\"\n  end\n  return data\nend\n\nfunction padding.toHex(data)\n    local inputHexTab = {}\n    for c in data:gmatch(\".\") do\n        table.insert(inputHexTab, string.format(\"%02x\", c:byte()))\n    end\n    return table.concat(inputHexTab, \"\")\nend\n\nfunction padding.fromHex(data)\n    return data:gsub(\n        \"%x%x\",\n        function(c)\n            return c.char(tonumber(c, 16))\n        end\n    )\nend\n\n--------------------------------------------------------------------------------\n-- aes part of aeslib\n--------------------------------------------------------------------------------\n\naesutil = {\n  _VERSION     = \"util.lua 0.2\",\n  _LICENSE     = [[\n    aeslua: Lua AES implementation\n    Copyright (c) 2006,2007 Matthias Hilbig\n\n    This program is free software; you can redistribute it and/or modify it\n    under the terms of the GNU Lesser Public License as published by the\n    Free Software Foundation; either version 2.1 of the License, or (at your\n    option) any later version.\n\n    This program is distributed in the hope that it will be useful, but\n    WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser Public License for more details.\n\n    A copy of the terms and conditions of the license can be found in\n    License.txt or online at\n\n    http://www.gnu.org/copyleft/lesser.html\n\n    To obtain a copy, write to the Free Software Foundation, Inc.,\n    59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n\n    Author\n    Matthias Hilbig\n    http://homepages.upb.de/hilbig/aeslua/\n    hilbig@upb.de \n  ]]\n}\n\n--\n-- calculate the parity of one byte\n--\nfunction aesutil.byteParity(byte)\n    byte = bit32.bxor(byte, bit32.rshift(byte, 4));\n    byte = bit32.bxor(byte, bit32.rshift(byte, 2));\n    byte = bit32.bxor(byte, bit32.rshift(byte, 1));\n    return bit32.band(byte, 1);\nend\n\n-- \n-- get byte at position index\n--\nfunction aesutil.getByte(number, index)\n    if (index == 0) then\n        return bit32.band(number,0xff);\n    else\n        return bit32.band(bit32.rshift(number, index*8),0xff);\n    end\nend\n\n--\n-- put number into int at position index\n--\nfunction aesutil.putByte(number, index)\n    if (index == 0) then\n        return bit32.band(number,0xff);\n    else\n        return bit32.lshift(bit32.band(number,0xff),index*8);\n    end\nend\n\n--\n-- convert byte array to int array\n--\nfunction aesutil.bytesToInts(bytes, start, n)\n    local ints = {};\n    for i = 0, n - 1 do\n        ints[i] = aesutil.putByte(bytes[start + (i*4)    ], 3)\n                + aesutil.putByte(bytes[start + (i*4) + 1], 2) \n                + aesutil.putByte(bytes[start + (i*4) + 2], 1)    \n                + aesutil.putByte(bytes[start + (i*4) + 3], 0);\n    end\n    return ints;\nend\n\n--\n-- convert int array to byte array\n--\nfunction aesutil.intsToBytes(ints, output, outputOffset, n)\n    n = n or #ints;\n    for i = 0, n do\n        for j = 0,3 do\n            output[outputOffset + i*4 + (3 - j)] = aesutil.getByte(ints[i], j);\n        end\n    end\n    return output;\nend\n\n--\n-- convert bytes to hexString\n--\nfunction aesutil.bytesToHex(bytes)\n    local hexBytes = \"\";\n    for i,byte in ipairs(bytes) do \n        hexBytes = hexBytes .. string.format(\"%02x \", byte);\n    end\n    return hexBytes;\nend\n\n--\n-- convert data to hex string\n--\nfunction aesutil.toHexString(data)\n    local type = type(data);\n    if (type == \"number\") then\n        return string.format(\"%08x\",data);\n    elseif (type == \"table\") then\n        return aesutil.bytesToHex(data);\n    elseif (type == \"string\") then\n        local bytes = {string.byte(data, 1, #data)}; \n        return aesutil.bytesToHex(bytes);\n    else\n        return data;\n    end\nend\n\nfunction aesutil.xorIV(data, iv)\n    for i = 1,16 do\n        data[i] = bit32.bxor(data[i], iv[i]);\n    end \nend\n\nfunction aesutil.increment(data)\n\tlocal i = 16\n\twhile true do\n\t\tlocal value = data[i] + 1\n\t\tif value >= 256 then\n\t\t\tdata[i] = value - 256\n\t\t\ti = (i - 2) % 16 + 1\n\t\telse\n\t\t\tdata[i] = value\n\t\t\tbreak\n\t\tend\n\tend\nend\n\n--------------------------------------------------------------------------------\n\naeslibgf = {\n  _VERSION     = \"gf.lua 0.2\",\n  _LICENSE     = [[\n    aeslua: Lua AES implementation\n    Copyright (c) 2006,2007 Matthias Hilbig\n\n    This program is free software; you can redistribute it and/or modify it\n    under the terms of the GNU Lesser Public License as published by the\n    Free Software Foundation; either version 2.1 of the License, or (at your\n    option) any later version.\n\n    This program is distributed in the hope that it will be useful, but\n    WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser Public License for more details.\n\n    A copy of the terms and conditions of the license can be found in\n    License.txt or online at\n\n    http://www.gnu.org/copyleft/lesser.html\n\n    To obtain a copy, write to the Free Software Foundation, Inc.,\n    59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n\n    Author\n    Matthias Hilbig\n    http://homepages.upb.de/hilbig/aeslua/\n    hilbig@upb.de \n  ]]\n}\n\n-- gf data of gf\naeslibgf.n = 0x100;\naeslibgf.ord = 0xff;\naeslibgf.irrPolynom = 0x11b;\naeslibgf.exp = {};\naeslibgf.log = {};\n\n--\n-- add two polynoms (its simply xor)\n--\nfunction aeslibgf.add(operand1, operand2) \n\treturn bit32.bxor(operand1,operand2);\nend\n\n-- \n-- subtract two polynoms (same as addition)\n--\nfunction aeslibgf.sub(operand1, operand2) \n\treturn bit32.bxor(operand1,operand2);\nend\n\n--\n-- inverts element a^(-1) = g^(order - log(a))\n--\nfunction aeslibgf.invert(operand)\n\t-- special case for 1 \n\tif (operand == 1) then\n\t\treturn 1;\n\tend;\n\t-- normal invert\n\tlocal exponent = aeslibgf.ord - aeslibgf.log[operand];\n\treturn aeslibgf.exp[exponent];\nend\n\n--\n-- multiply two elements using a logarithm table\n-- a*b = g^(log(a)+log(b))\n--\nfunction aeslibgf.mul(operand1, operand2)\n    if (operand1 == 0 or operand2 == 0) then\n        return 0;\n    end\n\t\n    local exponent = aeslibgf.log[operand1] + aeslibgf.log[operand2];\n\tif (exponent >= aeslibgf.ord) then\n\t\texponent = exponent - aeslibgf.ord;\n\tend\n\treturn  aeslibgf.exp[exponent];\nend\n\n--\n-- divide two elements\n-- a/b = g^(log(a)-log(b))\n--\nfunction aeslibgf.div(operand1, operand2)\n    if (operand1 == 0)  then\n        return 0;\n    end\n    -- TODO: exception if operand2 == 0\n\tlocal exponent = aeslibgf.log[operand1] - aeslibgf.log[operand2];\n\tif (exponent < 0) then\n\t\texponent = exponent + aeslibgf.ord;\n\tend\n\treturn aeslibgf.exp[exponent];\nend\n\n--\n-- print logarithmic table\n--\nfunction aeslibgf.printLog()\n\tfor i = 1, aeslibgf.n do\n\t\tprint(\"log(\", i-1, \")=\", aeslibgf.log[i-1]);\n\tend\nend\n\n--\n-- print exponentiation table\n--\nfunction aeslibgf.printExp()\n\tfor i = 1, aeslibgf.n do\n\t\tprint(\"exp(\", i-1, \")=\", aeslibgf.exp[i-1]);\n\tend\nend\n\n--\n-- calculate logarithmic and exponentiation table\n--\nfunction aeslibgf.initMulTable()\n\tlocal a = 1;\n\tfor i = 0,aeslibgf.ord-1 do\n    \taeslibgf.exp[i] = a;\n\t\taeslibgf.log[a] = i;\n\t\t-- multiply with generator x+1 -> left shift + 1\t\n\t\ta = bit32.bxor(bit32.lshift(a, 1), a);\n\t\t-- if a gets larger than order, reduce modulo irreducible polynom\n\t\tif a > aeslibgf.ord then\n\t\t\ta = aeslibgf.sub(a, aeslibgf.irrPolynom);\n\t\tend\n\tend\nend\n\naeslibgf.initMulTable();\n\n--------------------------------------------------------------------------------\n\naeslibbuffer = {\n  _VERSION     = \"buffer.lua 0.2\",\n  _LICENSE     = [[\n    aeslua: Lua AES implementation\n    Copyright (c) 2006,2007 Matthias Hilbig\n\n    This program is free software; you can redistribute it and/or modify it\n    under the terms of the GNU Lesser Public License as published by the\n    Free Software Foundation; either version 2.1 of the License, or (at your\n    option) any later version.\n\n    This program is distributed in the hope that it will be useful, but\n    WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser Public License for more details.\n\n    A copy of the terms and conditions of the license can be found in\n    License.txt or online at\n\n    http://www.gnu.org/copyleft/lesser.html\n\n    To obtain a copy, write to the Free Software Foundation, Inc.,\n    59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n\n    Author\n    Matthias Hilbig\n    http://homepages.upb.de/hilbig/aeslua/\n    hilbig@upb.de \n  ]]\n}\n\nfunction aeslibbuffer.new()\n  return {};\nend\n\nfunction aeslibbuffer.addString(stack, s)\n  table.insert(stack, s)\n  for i = #stack - 1, 1, -1 do\n    if #stack[i] > #stack[i+1] then \n        break;\n    end\n    stack[i] = stack[i] .. table.remove(stack);\n  end\nend\n\nfunction aeslibbuffer.toString(stack)\n  for i = #stack - 1, 1, -1 do\n    stack[i] = stack[i] .. table.remove(stack);\n  end\n  return stack[1];\nend\n\n--------------------------------------------------------------------------------\n\naes = {\n  _VERSION     = \"aes.lua 0.2\",\n  _LICENSE     = [[\n    aeslua: Lua AES implementation\n    Copyright (c) 2006,2007 Matthias Hilbig\n\n    This program is free software; you can redistribute it and/or modify it\n    under the terms of the GNU Lesser Public License as published by the\n    Free Software Foundation; either version 2.1 of the License, or (at your\n    option) any later version.\n\n    This program is distributed in the hope that it will be useful, but\n    WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser Public License for more details.\n\n    A copy of the terms and conditions of the license can be found in\n    License.txt or online at\n\n    http://www.gnu.org/copyleft/lesser.html\n\n    To obtain a copy, write to the Free Software Foundation, Inc.,\n    59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n\n    Author\n    Matthias Hilbig\n    http://homepages.upb.de/hilbig/aeslua/\n    hilbig@upb.de \n  ]]\n}\n\n-- some constants\naes.ROUNDS = \"rounds\";\naes.KEY_TYPE = \"type\";\naes.ENCRYPTION_KEY=1;\naes.DECRYPTION_KEY=2;\n\n-- aes SBOX\naes.SBox = {};\naes.iSBox = {};\n\n-- aes tables\naes.table0 = {};\naes.table1 = {};\naes.table2 = {};\naes.table3 = {};\n\naes.tableInv0 = {};\naes.tableInv1 = {};\naes.tableInv2 = {};\naes.tableInv3 = {};\n\n-- round constants\naes.rCon = {0x01000000, \n            0x02000000, \n            0x04000000, \n            0x08000000, \n            0x10000000, \n            0x20000000, \n            0x40000000, \n            0x80000000, \n            0x1b000000, \n            0x36000000,\n            0x6c000000,\n            0xd8000000,\n            0xab000000,\n            0x4d000000,\n            0x9a000000,\n            0x2f000000};\n\n--\n-- affine transformation for calculating the S-Box of AES\n--\nfunction aes.affinMap(byte)\n    mask = 0xf8;\n    result = 0;\n    for i = 1,8 do\n        result = bit32.lshift(result,1);\n        parity = aesutil.byteParity(bit32.band(byte,mask)); \n        result = result + parity\n        -- simulate roll\n        lastbit = bit32.band(mask, 1);\n        mask = bit32.band(bit32.rshift(mask, 1),0xff);\n        if (lastbit ~= 0) then\n            mask = bit32.bor(mask, 0x80);\n        else\n            mask = bit32.band(mask, 0x7f);\n        end\n    end\n    return bit32.bxor(result, 0x63);\nend\n\n--\n-- calculate S-Box and inverse S-Box of AES\n-- apply affine transformation to inverse in finite field 2^8 \n--\nfunction aes.calcSBox() \n    for i = 0, 255 do\n    if (i ~= 0) then\n        inverse = aeslibgf.invert(i);\n    else\n        inverse = i;\n    end\n        mapped = aes.affinMap(inverse);                 \n        aes.SBox[i] = mapped;\n        aes.iSBox[mapped] = i;\n    end\nend\n\n--\n-- Calculate round tables\n-- round tables are used to calculate shiftRow, MixColumn and SubBytes \n-- with 4 table lookups and 4 xor operations.\n--\nfunction aes.calcRoundTables()\n    for x = 0,255 do\n        byte = aes.SBox[x];\n        aes.table0[x] = aesutil.putByte(aeslibgf.mul(0x03, byte), 0)\n                          + aesutil.putByte(             byte , 1)\n                          + aesutil.putByte(             byte , 2)\n                          + aesutil.putByte(aeslibgf.mul(0x02, byte), 3);\n        aes.table1[x] = aesutil.putByte(             byte , 0)\n                          + aesutil.putByte(             byte , 1)\n                          + aesutil.putByte(aeslibgf.mul(0x02, byte), 2)\n                          + aesutil.putByte(aeslibgf.mul(0x03, byte), 3);\n        aes.table2[x] = aesutil.putByte(             byte , 0)\n                          + aesutil.putByte(aeslibgf.mul(0x02, byte), 1)\n                          + aesutil.putByte(aeslibgf.mul(0x03, byte), 2)\n                          + aesutil.putByte(             byte , 3);\n        aes.table3[x] = aesutil.putByte(aeslibgf.mul(0x02, byte), 0)\n                          + aesutil.putByte(aeslibgf.mul(0x03, byte), 1)\n                          + aesutil.putByte(             byte , 2)\n                          + aesutil.putByte(             byte , 3);\n    end\nend\n\n--\n-- Calculate inverse round tables\n-- does the inverse of the normal roundtables for the equivalent \n-- decryption algorithm.\n--\nfunction aes.calcInvRoundTables()\n    for x = 0,255 do\n        byte = aes.iSBox[x];\n        aes.tableInv0[x] = aesutil.putByte(aeslibgf.mul(0x0b, byte), 0)\n                             + aesutil.putByte(aeslibgf.mul(0x0d, byte), 1)\n                             + aesutil.putByte(aeslibgf.mul(0x09, byte), 2)\n                             + aesutil.putByte(aeslibgf.mul(0x0e, byte), 3);\n        aes.tableInv1[x] = aesutil.putByte(aeslibgf.mul(0x0d, byte), 0)\n                             + aesutil.putByte(aeslibgf.mul(0x09, byte), 1)\n                             + aesutil.putByte(aeslibgf.mul(0x0e, byte), 2)\n                             + aesutil.putByte(aeslibgf.mul(0x0b, byte), 3);\n        aes.tableInv2[x] = aesutil.putByte(aeslibgf.mul(0x09, byte), 0)\n                             + aesutil.putByte(aeslibgf.mul(0x0e, byte), 1)\n                             + aesutil.putByte(aeslibgf.mul(0x0b, byte), 2)\n                             + aesutil.putByte(aeslibgf.mul(0x0d, byte), 3);\n        aes.tableInv3[x] = aesutil.putByte(aeslibgf.mul(0x0e, byte), 0)\n                             + aesutil.putByte(aeslibgf.mul(0x0b, byte), 1)\n                             + aesutil.putByte(aeslibgf.mul(0x0d, byte), 2)\n                             + aesutil.putByte(aeslibgf.mul(0x09, byte), 3);\n    end\nend\n\n--\n-- rotate word: 0xaabbccdd gets 0xbbccddaa\n-- used for key schedule\n--\nfunction aes.rotWord(word)\n    local tmp = bit32.band(word,0xff000000);\n    return (bit32.lshift(word,8) + bit32.rshift(tmp,24)) ;\nend\n\n--\n-- replace all bytes in a word with the SBox.\n-- used for key schedule\n--\nfunction aes.subWord(word)\n    return aesutil.putByte(aes.SBox[aesutil.getByte(word,0)],0) \n         + aesutil.putByte(aes.SBox[aesutil.getByte(word,1)],1) \n         + aesutil.putByte(aes.SBox[aesutil.getByte(word,2)],2)\n         + aesutil.putByte(aes.SBox[aesutil.getByte(word,3)],3);\nend\n\n--\n-- generate key schedule for aes encryption\n--\n-- returns table with all round keys and\n-- the necessary number of rounds saved in [aes.ROUNDS]\n--\nfunction aes.expandEncryptionKey(key)\n    local keySchedule = {};\n    local keyWords = math.floor(#key / 4);\n    if ((keyWords ~= 4 and keyWords ~= 6 and keyWords ~= 8) or (keyWords * 4 ~= #key)) then\n        print(\"Invalid key size: \", keyWords);\n        return nil;\n    end\n    keySchedule[aes.ROUNDS] = keyWords + 6;\n    keySchedule[aes.KEY_TYPE] = aes.ENCRYPTION_KEY;\n    for i = 0,keyWords - 1 do\n        keySchedule[i] = aesutil.putByte(key[i*4+1], 3) \n                       + aesutil.putByte(key[i*4+2], 2)\n                       + aesutil.putByte(key[i*4+3], 1)\n                       + aesutil.putByte(key[i*4+4], 0);  \n    end\n    for i = keyWords, (keySchedule[aes.ROUNDS] + 1)*4 - 1 do\n        local tmp = keySchedule[i-1];\n        if ( i % keyWords == 0) then\n            tmp = aes.rotWord(tmp);\n            tmp = aes.subWord(tmp);\n            \n            local index = math.floor(i/keyWords);\n            tmp = bit32.bxor(tmp,aes.rCon[index]);\n        elseif (keyWords > 6 and i % keyWords == 4) then\n            tmp = aes.subWord(tmp);\n        end\n        keySchedule[i] = bit32.bxor(keySchedule[(i-keyWords)],tmp);\n    end\n    return keySchedule;\nend\n\n--\n-- Inverse mix column\n-- used for key schedule of decryption key\n--\nfunction aes.invMixColumnOld(word)\n    local b0 = aesutil.getByte(word,3);\n    local b1 = aesutil.getByte(word,2);\n    local b2 = aesutil.getByte(word,1);\n    local b3 = aesutil.getByte(word,0);\n    return aesutil.putByte(aeslibgf.add(aeslibgf.add(aeslibgf.add(aeslibgf.mul(0x0b, b1), \n                                             aeslibgf.mul(0x0d, b2)), \n                                             aeslibgf.mul(0x09, b3)), \n                                             aeslibgf.mul(0x0e, b0)),3)\n         + aesutil.putByte(aeslibgf.add(aeslibgf.add(aeslibgf.add(aeslibgf.mul(0x0b, b2), \n                                             aeslibgf.mul(0x0d, b3)), \n                                             aeslibgf.mul(0x09, b0)), \n                                             aeslibgf.mul(0x0e, b1)),2)\n         + aesutil.putByte(aeslibgf.add(aeslibgf.add(aeslibgf.add(aeslibgf.mul(0x0b, b3), \n                                             aeslibgf.mul(0x0d, b0)), \n                                             aeslibgf.mul(0x09, b1)), \n                                             aeslibgf.mul(0x0e, b2)),1)\n         + aesutil.putByte(aeslibgf.add(aeslibgf.add(aeslibgf.add(aeslibgf.mul(0x0b, b0), \n                                             aeslibgf.mul(0x0d, b1)), \n                                             aeslibgf.mul(0x09, b2)), \n                                             aeslibgf.mul(0x0e, b3)),0);\nend\n\n-- \n-- Optimized inverse mix column\n-- look at http://fp.gladman.plus.com/cryptography_technology/rijndael/aes.spec.311.pdf\n-- TODO: make it work\n--\nfunction aes.invMixColumn(word)\n    local b0 = aesutil.getByte(word,3);\n    local b1 = aesutil.getByte(word,2);\n    local b2 = aesutil.getByte(word,1);\n    local b3 = aesutil.getByte(word,0);\n    local t = bit32.bxor(b3,b2);\n    local u = bit32.bxor(b1,b0);\n    local v = bit32.bxor(t,u);\n    v = bit32.bxor(v,aeslibgf.mul(0x08,v));\n    w = bit32.bxor(v,aeslibgf.mul(0x04, bit32.bxor(b2,b0)));\n    v = bit32.bxor(v,aeslibgf.mul(0x04, bit32.bxor(b3,b1)));\n    return aesutil.putByte( bit32.bxor(bit32.bxor(b3,v), aeslibgf.mul(0x02, bit32.bxor(b0,b3))), 0)\n         + aesutil.putByte( bit32.bxor(bit32.bxor(b2,w), aeslibgf.mul(0x02, t              )), 1)\n         + aesutil.putByte( bit32.bxor(bit32.bxor(b1,v), aeslibgf.mul(0x02, bit32.bxor(b0,b3))), 2)\n         + aesutil.putByte( bit32.bxor(bit32.bxor(b0,w), aeslibgf.mul(0x02, u              )), 3);\nend\n\n--\n-- generate key schedule for aes decryption\n--\n-- uses key schedule for aes encryption and transforms each\n-- key by inverse mix column. \n--\nfunction aes.expandDecryptionKey(key)\n    local keySchedule = aes.expandEncryptionKey(key);\n    if (keySchedule == nil) then\n        return nil;\n    end\n    keySchedule[aes.KEY_TYPE] = aes.DECRYPTION_KEY;    \n    for i = 4, (keySchedule[aes.ROUNDS] + 1)*4 - 5 do\n        keySchedule[i] = aes.invMixColumnOld(keySchedule[i]);\n    end\n    return keySchedule;\nend\n\n--\n-- xor round key to state\n--\nfunction aes.addRoundKey(state, key, round)\n    for i = 0, 3 do\n        state[i] = bit32.bxor(state[i], key[round*4+i]);\n    end\nend\n\n--\n-- do encryption round (ShiftRow, SubBytes, MixColumn together)\n--\nfunction aes.doRound(origState, dstState)\n    dstState[0] =  bit32.bxor(bit32.bxor(bit32.bxor(\n                aes.table0[aesutil.getByte(origState[0],3)],\n                aes.table1[aesutil.getByte(origState[1],2)]),\n                aes.table2[aesutil.getByte(origState[2],1)]),\n                aes.table3[aesutil.getByte(origState[3],0)]);\n\n    dstState[1] =  bit32.bxor(bit32.bxor(bit32.bxor(\n                aes.table0[aesutil.getByte(origState[1],3)],\n                aes.table1[aesutil.getByte(origState[2],2)]),\n                aes.table2[aesutil.getByte(origState[3],1)]),\n                aes.table3[aesutil.getByte(origState[0],0)]);\n    \n    dstState[2] =  bit32.bxor(bit32.bxor(bit32.bxor(\n                aes.table0[aesutil.getByte(origState[2],3)],\n                aes.table1[aesutil.getByte(origState[3],2)]),\n                aes.table2[aesutil.getByte(origState[0],1)]),\n                aes.table3[aesutil.getByte(origState[1],0)]);\n    \n    dstState[3] =  bit32.bxor(bit32.bxor(bit32.bxor(\n                aes.table0[aesutil.getByte(origState[3],3)],\n                aes.table1[aesutil.getByte(origState[0],2)]),\n                aes.table2[aesutil.getByte(origState[1],1)]),\n                aes.table3[aesutil.getByte(origState[2],0)]);\nend\n\n--\n-- do last encryption round (ShiftRow and SubBytes)\n--\nfunction aes.doLastRound(origState, dstState)\n    dstState[0] = aesutil.putByte(aes.SBox[aesutil.getByte(origState[0],3)], 3)\n                + aesutil.putByte(aes.SBox[aesutil.getByte(origState[1],2)], 2)\n                + aesutil.putByte(aes.SBox[aesutil.getByte(origState[2],1)], 1)\n                + aesutil.putByte(aes.SBox[aesutil.getByte(origState[3],0)], 0);\n\n    dstState[1] = aesutil.putByte(aes.SBox[aesutil.getByte(origState[1],3)], 3)\n                + aesutil.putByte(aes.SBox[aesutil.getByte(origState[2],2)], 2)\n                + aesutil.putByte(aes.SBox[aesutil.getByte(origState[3],1)], 1)\n                + aesutil.putByte(aes.SBox[aesutil.getByte(origState[0],0)], 0);\n\n    dstState[2] = aesutil.putByte(aes.SBox[aesutil.getByte(origState[2],3)], 3)\n                + aesutil.putByte(aes.SBox[aesutil.getByte(origState[3],2)], 2)\n                + aesutil.putByte(aes.SBox[aesutil.getByte(origState[0],1)], 1)\n                + aesutil.putByte(aes.SBox[aesutil.getByte(origState[1],0)], 0);\n\n    dstState[3] = aesutil.putByte(aes.SBox[aesutil.getByte(origState[3],3)], 3)\n                + aesutil.putByte(aes.SBox[aesutil.getByte(origState[0],2)], 2)\n                + aesutil.putByte(aes.SBox[aesutil.getByte(origState[1],1)], 1)\n                + aesutil.putByte(aes.SBox[aesutil.getByte(origState[2],0)], 0);\nend\n\n--\n-- do decryption round \n--\nfunction aes.doInvRound(origState, dstState)\n    dstState[0] =  bit32.bxor(bit32.bxor(bit32.bxor(\n                aes.tableInv0[aesutil.getByte(origState[0],3)],\n                aes.tableInv1[aesutil.getByte(origState[3],2)]),\n                aes.tableInv2[aesutil.getByte(origState[2],1)]),\n                aes.tableInv3[aesutil.getByte(origState[1],0)]);\n\n    dstState[1] =  bit32.bxor(bit32.bxor(bit32.bxor(\n                aes.tableInv0[aesutil.getByte(origState[1],3)],\n                aes.tableInv1[aesutil.getByte(origState[0],2)]),\n                aes.tableInv2[aesutil.getByte(origState[3],1)]),\n                aes.tableInv3[aesutil.getByte(origState[2],0)]);\n    \n    dstState[2] =  bit32.bxor(bit32.bxor(bit32.bxor(\n                aes.tableInv0[aesutil.getByte(origState[2],3)],\n                aes.tableInv1[aesutil.getByte(origState[1],2)]),\n                aes.tableInv2[aesutil.getByte(origState[0],1)]),\n                aes.tableInv3[aesutil.getByte(origState[3],0)]);\n    \n    dstState[3] =  bit32.bxor(bit32.bxor(bit32.bxor(\n                aes.tableInv0[aesutil.getByte(origState[3],3)],\n                aes.tableInv1[aesutil.getByte(origState[2],2)]),\n                aes.tableInv2[aesutil.getByte(origState[1],1)]),\n                aes.tableInv3[aesutil.getByte(origState[0],0)]);\nend\n\n--\n-- do last decryption round\n--\nfunction aes.doInvLastRound(origState, dstState)\n    dstState[0] = aesutil.putByte(aes.iSBox[aesutil.getByte(origState[0],3)], 3)\n                + aesutil.putByte(aes.iSBox[aesutil.getByte(origState[3],2)], 2)\n                + aesutil.putByte(aes.iSBox[aesutil.getByte(origState[2],1)], 1)\n                + aesutil.putByte(aes.iSBox[aesutil.getByte(origState[1],0)], 0);\n\n    dstState[1] = aesutil.putByte(aes.iSBox[aesutil.getByte(origState[1],3)], 3)\n                + aesutil.putByte(aes.iSBox[aesutil.getByte(origState[0],2)], 2)\n                + aesutil.putByte(aes.iSBox[aesutil.getByte(origState[3],1)], 1)\n                + aesutil.putByte(aes.iSBox[aesutil.getByte(origState[2],0)], 0);\n\n    dstState[2] = aesutil.putByte(aes.iSBox[aesutil.getByte(origState[2],3)], 3)\n                + aesutil.putByte(aes.iSBox[aesutil.getByte(origState[1],2)], 2)\n                + aesutil.putByte(aes.iSBox[aesutil.getByte(origState[0],1)], 1)\n                + aesutil.putByte(aes.iSBox[aesutil.getByte(origState[3],0)], 0);\n\n    dstState[3] = aesutil.putByte(aes.iSBox[aesutil.getByte(origState[3],3)], 3)\n                + aesutil.putByte(aes.iSBox[aesutil.getByte(origState[2],2)], 2)\n                + aesutil.putByte(aes.iSBox[aesutil.getByte(origState[1],1)], 1)\n                + aesutil.putByte(aes.iSBox[aesutil.getByte(origState[0],0)], 0);\nend\n\n--\n-- encrypts 16 Bytes\n-- key           encryption key schedule\n-- input         array with input data\n-- inputOffset   start index for input\n-- output        array for encrypted data\n-- outputOffset  start index for output\n--\nfunction aes.encrypt(key, input, inputOffset, output, outputOffset) \n    --default parameters\n    inputOffset = inputOffset or 1;\n    output = output or {};\n    outputOffset = outputOffset or 1;\n    local state = {};\n    local tmpState = {};\n    if (key[aes.KEY_TYPE] ~= aes.ENCRYPTION_KEY) then\n        print(\"No encryption key: \", key[aes.KEY_TYPE]);\n        return;\n    end\n    state = aesutil.bytesToInts(input, inputOffset, 4);\n    aes.addRoundKey(state, key, 0);\n    local round = 1;\n    while (round < key[aes.ROUNDS] - 1) do\n        -- do a double round to save temporary assignments\n        aes.doRound(state, tmpState);\n        aes.addRoundKey(tmpState, key, round);\n        round = round + 1;\n        aes.doRound(tmpState, state);\n        aes.addRoundKey(state, key, round);\n        round = round + 1;\n    end\n    aes.doRound(state, tmpState);\n    aes.addRoundKey(tmpState, key, round);\n    round = round +1;\n    aes.doLastRound(tmpState, state);\n    aes.addRoundKey(state, key, round);\n    return aesutil.intsToBytes(state, output, outputOffset);\nend\n\n--\n-- decrypt 16 bytes\n-- key           decryption key schedule\n-- input         array with input data\n-- inputOffset   start index for input\n-- output        array for decrypted data\n-- outputOffset  start index for output\n---\nfunction aes.decrypt(key, input, inputOffset, output, outputOffset) \n    -- default arguments\n    inputOffset = inputOffset or 1;\n    output = output or {};\n    outputOffset = outputOffset or 1;\n    local state = {};\n    local tmpState = {};\n    if (key[aes.KEY_TYPE] ~= aes.DECRYPTION_KEY) then\n        print(\"No decryption key: \", key[aes.KEY_TYPE]);\n        return;\n    end\n    state = aesutil.bytesToInts(input, inputOffset, 4);\n    aes.addRoundKey(state, key, key[aes.ROUNDS]);\n    local round = key[aes.ROUNDS] - 1;\n    while (round > 2) do\n        -- do a double round to save temporary assignments\n        aes.doInvRound(state, tmpState);\n        aes.addRoundKey(tmpState, key, round);\n        round = round - 1;\n\n        aes.doInvRound(tmpState, state);\n        aes.addRoundKey(state, key, round);\n        round = round - 1;\n    end\n    aes.doInvRound(state, tmpState);\n    aes.addRoundKey(tmpState, key, round);\n    round = round - 1;\n    aes.doInvLastRound(tmpState, state);\n    aes.addRoundKey(state, key, round);\n    return aesutil.intsToBytes(state, output, outputOffset);\nend\n\n-- calculate all tables when loading this file\naes.calcSBox();\naes.calcRoundTables();\naes.calcInvRoundTables();\n\n--------------------------------------------------------------------------------\n\nciphermode = {\n  _VERSION     = \"ciphermode.lua 0.2\",\n  _LICENSE     = [[\n    aeslua: Lua AES implementation\n    Copyright (c) 2006,2007 Matthias Hilbig\n\n    This program is free software; you can redistribute it and/or modify it\n    under the terms of the GNU Lesser Public License as published by the\n    Free Software Foundation; either version 2.1 of the License, or (at your\n    option) any later version.\n\n    This program is distributed in the hope that it will be useful, but\n    WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser Public License for more details.\n\n    A copy of the terms and conditions of the license can be found in\n    License.txt or online at\n\n    http://www.gnu.org/copyleft/lesser.html\n\n    To obtain a copy, write to the Free Software Foundation, Inc.,\n    59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n\n    Author\n    Matthias Hilbig\n    http://homepages.upb.de/hilbig/aeslua/\n    hilbig@upb.de \n  ]]\n}\n\n--\n-- Encrypt strings\n-- key - byte array with key\n-- string - string to encrypt\n-- modefunction - function for cipher mode to use\n-- iv - optional iv for modefunction\n--\nfunction ciphermode.encryptString(key, data, modeFunction, iv)\n\tif iv then\n\t\tlocal ivCopy = {}\n\t\tfor i = 1, 16 do ivCopy[i] = iv[i] end\n\t\tiv = ivCopy\n\telse\n\t\tiv = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}\n\tend\n\tlocal keySched = aes.expandEncryptionKey(key)\n\tlocal encryptedData = aeslibbuffer.new()\n\tfor i = 1, #data/16 do\n\t\tlocal offset = (i-1)*16 + 1\n\t\tlocal byteData = {string.byte(data,offset,offset +15)}\n\t\tiv = modeFunction(keySched, byteData, iv)\n\t\taeslibbuffer.addString(encryptedData, string.char(unpack(byteData)))\n\tend\n\treturn aeslibbuffer.toString(encryptedData)\nend\n\n--\n-- the following 4 functions can be used as \n-- modefunction for encryptString\n--\nfunction ciphermode.encryptECB(keySched, byteData, iv) \n\taes.encrypt(keySched, byteData, 1, byteData, 1)\nend\n\n-- Cipher block chaining mode encrypt function\nfunction ciphermode.encryptCBC(keySched, byteData, iv)\n\taesutil.xorIV(byteData, iv)\n\taes.encrypt(keySched, byteData, 1, byteData, 1)\n\treturn byteData\nend\n\n-- Output feedback mode encrypt function\nfunction ciphermode.encryptOFB(keySched, byteData, iv)\n\taes.encrypt(keySched, iv, 1, iv, 1)\n\taesutil.xorIV(byteData, iv)\n\treturn iv\nend\n\n-- Cipher feedback mode encrypt function\nfunction ciphermode.encryptCFB(keySched, byteData, iv) \n\taes.encrypt(keySched, iv, 1, iv, 1)\n\taesutil.xorIV(byteData, iv)\n\treturn byteData       \nend\n\nfunction ciphermode.encryptCTR(keySched, byteData, iv)\n\tlocal nextIV = {}\n\tfor j = 1, 16 do nextIV[j] = iv[j] end\n\taes.encrypt(keySched, iv, 1, iv, 1)\n\taesutil.xorIV(byteData, iv)\n\taesutil.increment(nextIV)\n\treturn nextIV\nend\n\n--\n-- Decrypt strings\n-- key - byte array with key\n-- string - string to decrypt\n-- modefunction - function for cipher mode to use\n-- iv - optional iv for modefunction\n--\nfunction ciphermode.decryptString(key, data, modeFunction, iv)\n    if iv then\n\t\tlocal ivCopy = {}\n\t\tfor i = 1, 16 do ivCopy[i] = iv[i] end\n\t\tiv = ivCopy\n\telse\n\t\tiv = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}\n\tend\n    local keySched\n    if (modeFunction == ciphermode.decryptOFB or modeFunction == ciphermode.decryptCFB or modeFunction == ciphermode.decryptCTR) then\n    \tkeySched = aes.expandEncryptionKey(key)\n   \telse\n   \t\tkeySched = aes.expandDecryptionKey(key)\n    end\n    local decryptedData = aeslibbuffer.new()\n    for i = 1, #data/16 do\n        local offset = (i-1)*16 + 1\n        local byteData = {string.byte(data,offset,offset +15)}\n\t\tiv = modeFunction(keySched, byteData, iv)\n        aeslibbuffer.addString(decryptedData, string.char(unpack(byteData)))\n    end\n    return aeslibbuffer.toString(decryptedData)\nend\n\n--\n-- the following 4 functions can be used as \n-- modefunction for decryptString\n--\nfunction ciphermode.decryptECB(keySched, byteData, iv)\n    aes.decrypt(keySched, byteData, 1, byteData, 1)\n    return iv\nend\n\n-- Cipher block chaining mode decrypt function\nfunction ciphermode.decryptCBC(keySched, byteData, iv)\n\tlocal nextIV = {}\n\tfor j = 1, 16 do nextIV[j] = byteData[j] end\n\taes.decrypt(keySched, byteData, 1, byteData, 1)\n\taesutil.xorIV(byteData, iv)\n\treturn nextIV\nend\n\n-- Output feedback mode decrypt function\nfunction ciphermode.decryptOFB(keySched, byteData, iv)\n\taes.encrypt(keySched, iv, 1, iv, 1)\n\taesutil.xorIV(byteData, iv)\n\treturn iv\nend\n\n-- Cipher feedback mode decrypt function\nfunction ciphermode.decryptCFB(keySched, byteData, iv)\n\tlocal nextIV = {}\n\tfor j = 1, 16 do nextIV[j] = byteData[j] end\n\taes.encrypt(keySched, iv, 1, iv, 1)\n\taesutil.xorIV(byteData, iv)\n\treturn nextIV\nend\n\nciphermode.decryptCTR = ciphermode.encryptCTR\n\n--------------------------------------------- end of lib --------------------------------------------- \n"},{"name":"base64","isMain":false,"isOpen":false,"content":"-- FIBARO HC3 LUA lib 'common.base64'\n-- Copyright Fibar Group S.A\n--\nbase64 = {\n  _VERSION     = \"0.1\",\n  _DESCRIPTION = \"Base64_encode, Base64_decode\",\n  _URL         = \"http://quickapps.info\",\n  _LICENSE     = [[\n  ]]\n}\n\nlocal index_table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nlocal function to_binary(integer)\n    local remaining = tonumber(integer)\n    local bin_bits = ''\n\n    for i = 7, 0, -1 do\n        local current_power = math.pow(2, i)\n\n        if remaining >= current_power then\n            bin_bits = bin_bits .. '1'\n            remaining = remaining - current_power\n        else\n            bin_bits = bin_bits .. '0'\n        end\n    end\n\n    return bin_bits\nend\n\nlocal function from_binary(bin_bits)\n    return tonumber(bin_bits, 2)\nend\n\nfunction base64.to_base64(to_encode)\n    local bit_pattern = ''\n    local encoded = ''\n    local trailing = ''\n\n    for i = 1, string.len(to_encode) do\n        bit_pattern = bit_pattern .. to_binary(string.byte(string.sub(to_encode, i, i)))\n    end\n\n    -- Check the number of bytes. If it's not evenly divisible by three,\n    -- zero-pad the ending & append on the correct number of ``=``s.\n    if math.fmod(string.len(bit_pattern), 3) == 2 then\n        trailing = '=='\n        bit_pattern = bit_pattern .. '0000000000000000'\n    elseif math.fmod(string.len(bit_pattern), 3) == 1 then\n        trailing = '='\n        bit_pattern = bit_pattern .. '00000000'\n    end\n\n    for i = 1, string.len(bit_pattern), 6 do\n        local byte = string.sub(bit_pattern, i, i+5)\n        local offset = tonumber(from_binary(byte))\n        encoded = encoded .. string.sub(index_table, offset+1, offset+1)\n    end\n\n    return string.sub(encoded, 1, -1 - string.len(trailing)) .. trailing\nend\n\nfunction base64.from_base64(to_decode)\n    local padded = to_decode:gsub(\"%s\", \"\")\n    local unpadded = padded:gsub(\"=\", \"\")\n    local bit_pattern = ''\n    local decoded = ''\n\n    for i = 1, string.len(unpadded) do\n        local char = string.sub(to_decode, i, i)\n        local offset, _ = string.find(index_table, char)\n        if offset == nil then\n             error(\"Invalid character '\" .. char .. \"' found.\")\n        end\n\n        bit_pattern = bit_pattern .. string.sub(to_binary(offset-1), 3)\n    end\n\n    for i = 1, string.len(bit_pattern), 8 do\n        local byte = string.sub(bit_pattern, i, i+7)\n        decoded = decoded .. string.char(from_binary(byte))\n    end\n\n    local padding_length = padded:len()-unpadded:len()\n\n    if (padding_length == 1 or padding_length == 2) then\n        decoded = decoded:sub(1,-2)\n    end\n    return decoded\nend"},{"name":"udplib","isMain":false,"isOpen":false,"content":"local udp = net.UDPSocket({ broadcast = true, timeout = 2000 })"}]}